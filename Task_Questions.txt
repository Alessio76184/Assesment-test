1) Algorithm: list characters appearing at least twice
-----------------------------------------------
Language: Python

def at_least_twice(chars: list[str]) -> list[str]:
    freq = {}
    for ch in chars:
        freq[ch] = freq.get(ch, 0) + 1
    seen = set()
    result = []
    for ch in chars:
        if ch not in seen and freq[ch] >= 2:
            result.append(ch)
            seen.add(ch)
    return result

# Example
example = ['c','a','i','o','p','a']
print(at_least_twice(example))  # -> ['a']

Time/space cost:
- Let n = length of input, k = number of distinct characters.
- Time: O(n) to count + O(n) to build ordered result = O(n) overall.
- Space: O(k) for the frequency map (+ O(k) for 'seen').

2) Do you know what a unit test is? And an integration test? What is the difference? What about a system test?
-----------------------------------------------
- Unit test - Is a small function, class, or method that is verfied in isolation from compotnents a sytem usually with run with mock dependecies or stubbed.
- Integration test -  A test run on a componet that to verify it works together with other componments.
- System test - Conducted to test the whole system for validation of the system as a user or an external systme.

3) Do you know design patterns? Describe one briefly.
-----------------------------------------------
I understand the concept of design patterns, which are proven ways to structure code so it’s easier to maintain and expand. For example, I’m familiar with the Strategy pattern, which encapsulates interchangeable algorithms behind a standard interface so they can be swapped without changing the calling code. In the code I developed for this task, for example, I applied the Single Responsibility Principle by placing the algorithm in one file and the tests in another. This improves reusability and makes the test harness adaptable for other functions, aligning with how design patterns promote separation of concerns.

4) Describe the pros and cons of writing a multi-process vs a multi-thread application
-----------------------------------------------
Multi-process applications' pros are that they are better for CPU and memory-intensive work and for situations where
you want to avoid one crash taking down the whole application. Each process runs independently, so they are more 
stable, but their cons are that they’re slower to start, use more memory, orchestration is far more complex, and it’s harder to share data between them.

Multi-threaded applications' pros are that they share the same memory, making them lighter and faster for tasks that
spend a lot of time waiting (like database queries or network requests). The cons are that threads can interfere with
each other if not managed carefully, which can cause crashes or unpredictable behaviour.

5) Most boring vs most satisfying
-----------------------------------------------
The boring part can be when progress is blocked by waiting for dependencies from other teams, as I am always eager to deliver and see my contribution in action. When that happens, I usually use the time to improve automation scripts, refactor code, research areas where I need to develop, or strengthen our test coverage so we’re ready when dependencies are resolved.
The most satisfying part is when a complex feature or integration works in production, and seeing all the parts we've worked on functioning reliably and adding real value is incredibly rewarding.

6) Explain and comment this Dockerfile.
-----------------------------------------------
FROM bitnami/minideb:latest

- Starts from a small Debian-based image by Bitnami.

RUN bash -c "echo \"$(< /dev/urandom tr -cd "[:print:]" | head -c 32; echo)\" > /tmp/auth"

- At build time, generates a random 32-character printable string and writes it to /tmp/auth (a temporary “auth” token).

RUN <<EOF cat > /remove
#!/usr/bin/env bash
test -f /tmp/auth && rm -f /tmp/auth
EOF

- It attaches the EOF and cat to /remove, and also should create the file if it has not been created already. It will then run the test /temp/auth and then remove it.

RUN chmod +x /remove; \
    bash /remove
    
- Makes the /remove executable and runs it, by placing multiple commands one after the other. The \ is used to place commands one after another

CMD ["/usr/bin/echo", "done"]

- default container command prints 'done' and exits.
